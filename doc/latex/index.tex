This project aims to show the use of reinforcement learning algorithm in finding a feedback policy for adaptive quantum-\/enhanced measurement, which has the goal of achieving the scaling in precision that exceeds the conventional techniques. We use adaptive phase estimation that includes phase noise and loss as the test problem.

The program is designed to streamline the implementation of population-\/based optimization algorithms on high-\/performance computing clusters and support parallel computing using M\+P\+I.

{\bfseries Features\+:}


\begin{DoxyItemize}
\item Easy selection of optimization algorithm and optimization problem
\item Libraries for differential evolution and particle swarm optimization
\item Both uniformly random and clustered initialization of population
\item Accept-\/reject criteria to ensure quantum-\/enhanced results
\item Support for V\+S\+L and G\+P\+U to provide fast random number generation
\end{DoxyItemize}

{\bfseries Limitation}

-\/\+The adaptive phase estimation is only reliable to 100 photons \mbox{[}Other limitation?\mbox{]}

\subsubsection*{Usage\+:}

As the program is designed to work on H\+P\+C clusters where interactive input from user might not be allowed, all the parameters are set within the code before compilation.

\paragraph*{Selecting problem and optimization algorithm}

The library for the optimization algorithm and the problem must be included in the headers of main.\+cpp. The objects in the corresponding classes can be set in the main function as pointers.


\begin{DoxyCode}
1 #include "mpi\_de.h"
2 #include "mpi\_pso.h"
\end{DoxyCode}


The optimization algorithms are instantiated with default parameters which can be changed within the code. For example, for differential evolution\+:


\begin{DoxyCode}
1 ...
2 
3 DE(Problem<typeT> *problem\_ptr): F(0.1), Cr(0.6) \{
4 
5 ...
\end{DoxyCode}


The library also contain a function for changing the parameters during runtime\+:


\begin{DoxyCode}
1 void DE<typeT>::write\_param(double *param\_array) \{
2 ...
\end{DoxyCode}


\paragraph*{Parameters setting}

The beginning of the main function contains a set of parameters including


\begin{DoxyItemize}
\item the smallest (N\+\_\+begin) and the largest number of variables (N\+\_\+end).
\item number of variables where the program use cluster initialization around previous solution (N\+\_\+cut)
\item number of variables where accept-\/reject criteria starts (data\+\_\+end)
\item population size (pop\+\_\+size)
\item number of iterations (iter, iter\+\_\+begin)
\end{DoxyItemize}

\paragraph*{Compilation}

The project contains the support for compilation using Autotools, and has been tested using G\+N\+U Compile Chain (G\+C\+C) and Intel Compilers. Intel V\+S\+L library and G\+P\+U are automatically detected.

In the first compilation, first run autogen.\+sh in order to create missing files and generate the executable configure from configure.\+ac. Then run the executable to generate Makefile from Makefile.\+in. The code can now be compiled. The sequence of the commands are


\begin{DoxyCode}
1 ./autogen.sh
2 
3 ./configure
4 
5 make
\end{DoxyCode}


Any job submission command should be directed to run src/phase\+\_\+estimation. The solution from the run are in the output file output.\+dat, and the time taken to run the program for each number of variables is in the file time.\+dat.

\subsubsection*{Acknowledgement\+:}

The computational work was enabled in part by support provided by West\+Grid (www.\+westgrid.\+ca) and Calcul Quebec (www.\+calculquebec.\+ca) through Compute Canada Calcul Canada (www.\+computecanada.\+ca).

\mbox{[}Should we include the funding sources\+: N\+S\+E\+R\+C, A\+I\+T\+F\mbox{]}

\subsubsection*{References\+:}

\mbox{[}To be include\+: manuscript on arxiv and manual -- what should be in the manual?\mbox{]} 