<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Evolutionary algorithm for adaptive phase estimation: C:/DATA/PROGRAM/GitHub/phase_estimation/src/phase_loss_opt.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Evolutionary algorithm for adaptive phase estimation
   &#160;<span id="projectnumber">1.0.2</span>
   </div>
   <div id="projectbrief">We implement evolutionary algorithm to the problem of adaptive phase estimation, which is an example of quantum control problems. The aim of this project is to create a library containing modules that streamlines the construction of an optimization algorithm for quantum control problems. Access to modules of optimization algorithms provides the building blocks that users can use to tweak the algorithm to their needs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">phase_loss_opt.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="phase__loss__opt_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;cstring&gt;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;stdexcept&gt;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span>std;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="phase__loss__opt_8h.html">phase_loss_opt.h</a>&quot;</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno"><a class="line" href="class_phase.html#a3400d37e26b0f5f785db31d7887a6d76">   10</a></span>&#160;<a class="code" href="class_phase.html#a3400d37e26b0f5f785db31d7887a6d76">Phase::Phase</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> numvar, <a class="code" href="rng_8h.html#a0d95a1c4bd7f6516941df17732a09356">Rng</a> *gaussian_rng, <a class="code" href="rng_8h.html#a0d95a1c4bd7f6516941df17732a09356">Rng</a> *uniform_rng):</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    gaussian_rng(gaussian_rng), uniform_rng(uniform_rng) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <span class="keywordflow">if</span>(numvar &lt;= 0) {</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordflow">throw</span> invalid_argument(<span class="stringliteral">&quot;numvar&lt;=0. Instantiating Phase fails.&quot;</span>);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        }</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordtype">int</span> i;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">//Initializing the conditions the simulation uses.</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    lower = 0;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    upper = 2 * M_PI;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    loss = 0.0;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="comment">//Initializing the numbers used by the optimization algorithm.</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> = numvar;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="class_problem.html#a11dbb1d5a91b82ac8bab777362003e43">num_fit</a> = 2;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="class_problem.html#a02dc7cd36750260516f536d4b519399d">num_repeat</a> = 10 * <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> * <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <span class="comment">//Initializing the lower bound and upper bound for the optimized variables.</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="class_problem.html#a4dfde0675e59264970f418516b799b2c">lower_bound</a> = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>];</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="class_problem.html#a02bd6d1e098e211cc3bf0f5e02f20133">upper_bound</a> = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>];</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++i) {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <a class="code" href="class_problem.html#a4dfde0675e59264970f418516b799b2c">lower_bound</a>[i] = lower;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <a class="code" href="class_problem.html#a02bd6d1e098e211cc3bf0f5e02f20133">upper_bound</a>[i] = upper;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        }</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="comment">//Initializing memories used by the simulation.</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    sqrt_cache = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1; ++i) {</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        sqrt_cache[i] = sqrt(i);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        }</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    input_state = <span class="keyword">new</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    sqrtfac_mat = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    overfac_mat = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    state = <span class="keyword">new</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    update0 = <span class="keyword">new</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    update1 = <span class="keyword">new</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a>[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    }</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno"><a class="line" href="class_phase.html#a9907413eb9a96148934d71864bb7e41b">   51</a></span>&#160;<a class="code" href="class_phase.html#a9907413eb9a96148934d71864bb7e41b">Phase::~Phase</a>() {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="comment">/*freeing the memory.</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">    * This is a crucial step if the main function runs a loop with multiple instantiation of the phase problem</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">    as the computer might run out of memory.</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keyword">delete</span>[] state;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keyword">delete</span>[] update0;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keyword">delete</span>[] update1;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keyword">delete</span>[] input_state;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keyword">delete</span>[] sqrtfac_mat;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keyword">delete</span>[] overfac_mat;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno"><a class="line" href="class_phase.html#ab25270a4c4dda786a14028daf70a1da8">   64</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_phase.html#ab25270a4c4dda786a14028daf70a1da8">Phase::fitness</a>(<span class="keywordtype">double</span> *soln, <span class="keywordtype">double</span> *fitarray) {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="comment">/*In this particular problem, this function serves as a wrapper to change the loss rate,</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">    * so that we can test the policy we found in lossless interferometry with a chosen level of loss.</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    loss = 0.2; <span class="comment">//This loss rate can be changed by user.</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <a class="code" href="class_phase.html#a73864e5e5e43b6fb301cf507eeb118a4">avg_fitness</a>(soln, <a class="code" href="class_problem.html#a02dc7cd36750260516f536d4b519399d">num_repeat</a>, fitarray);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    loss = 0.0; <span class="comment">//Change back in case the optimization process has to be redone.</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    }</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno"><a class="line" href="class_phase.html#a73864e5e5e43b6fb301cf507eeb118a4">   73</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_phase.html#a73864e5e5e43b6fb301cf507eeb118a4">Phase::avg_fitness</a>(<span class="keywordtype">double</span> *soln, <span class="keyword">const</span> <span class="keywordtype">int</span> K, <span class="keywordtype">double</span> *fitarray) {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="comment">/* A function calculates the fitness values (reported in fitarray) of a solution (soln) over a sample size of K.</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">    * This function simulates the adaptive phase interferometry and so is the most computationally expensive part of the program.</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a> sharp(0.0, 0.0); <span class="comment">//variable to store the sharpness function, which is the first fitness value in the array.</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordtype">double</span> error = 0.0; <span class="comment">//variable to store the bias of the estimate, which is the second fitness value in the array.</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordtype">bool</span> dect_result; <span class="comment">//variable to store which path a photon comes out at any step.</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordtype">double</span> PHI, phi, coin, PHI_in;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordtype">int</span> m, k, d;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    WK_state(); <span class="comment">//Generate the WK state.</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keywordflow">for</span>(k = 0; k &lt; K; ++k) {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        phi = uniform_rng-&gt;next_rand(0.0, 1.0) * (upper - lower) + lower;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        PHI = 0;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="comment">//copy input state: the optimal solution across all compilers is memcpy:</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="comment">//nadeausoftware.com/articles/2012/05/c_c_tip_how_copy_memory_quickly</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        memcpy(state, input_state, (<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1)*<span class="keyword">sizeof</span>(<a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a>));</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="comment">//Begining the measurement of one sample</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        d = 0;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">for</span> (m = 0; m &lt; <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++m) {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="comment">// This loop is the most critical part of the entire program. It</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="comment">// executes K*num=10*num^3 times on each call of avg_fitness. All</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="comment">// optimization should focus on this loop.</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="comment">//randomly decide whether loss occurs</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            coin = uniform_rng-&gt;next_rand(0.0, 1.0);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;            <span class="keywordflow">if</span>(coin &lt;= loss) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                state_loss(<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> - m); <span class="comment">//update only the state using loss function</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                }</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keywordflow">else</span> {</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <span class="comment">//PHI_in = rand_Gaussian(PHI, THETA_DEV); //select if the noise is normally distributed.</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="comment">//PHI_in = rand_Hat(PHI, THETA_DEV); //select if the noise is distributed as a Hat function.</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="comment">//PHI_in = Lognormal(MU,THETA,PHI); //select if the noise is distributed as a lognormal function.</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="comment">//PHI_in = rand_RTN(PHI,Ps,THETA_DEV);//select if the noise is random telegraph.</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        PHI_in = rand_skewed(PHI, <a class="code" href="phase__loss__opt_8h.html#a84ee68ee1444d9432f7dc7e67b7e5f51">THETA_DEV</a>, <a class="code" href="phase__loss__opt_8h.html#a7e8b3c8482e593df0ace933ad3de22ee">RATIO</a>); <span class="comment">//select if the noise is skewed normal.</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                PHI_in = mod_2PI(PHI_in);<span class="comment">//noisy PHI</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                dect_result = noise_outcome(phi, PHI_in, <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> - m);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                <span class="keywordflow">if</span> (dect_result == 0) {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                    PHI = PHI - soln[d++];</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                    }</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                <span class="keywordflow">else</span> {</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                    PHI = PHI + soln[d++];</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                    }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                PHI = mod_2PI(PHI);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                }</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="comment">//store fitness values</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        sharp.real(sharp.real() + cos(phi - PHI));</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        sharp.imag(sharp.imag() + sin(phi - PHI));</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">//find the averages and return</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    fitarray[0] = abs(sharp) / double(K); <span class="comment">//Calculate the dispersion</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    fitarray[1] = atan2(sharp.imag(),sharp.real()); <span class="comment">//Calculate the mean direction</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    }</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno"><a class="line" href="class_phase.html#ab7c1a08ef8d03c0e1ec72caf0056a5f0">  130</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_phase.html#ab7c1a08ef8d03c0e1ec72caf0056a5f0">Phase::T_condition</a>(<span class="keywordtype">double</span> *fitarray, <span class="keywordtype">int</span> *numvar, <span class="keywordtype">int</span> N_cut, <span class="keywordtype">bool</span> *mem_ptype, <span class="keywordtype">double</span> *memory_forT) {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="comment">/*This function contains the conditions that has to be checked after a step T elapses</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">    * before the algorithm decides to accept or reject the solution.</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">    * In particular this function is called when time step is used as the main condition to end the optimization.</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">    * For this particular problem, it resets the number of variables so the optimization starts over.</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">//Let&#39;s start this condition from scratch.</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keywordtype">bool</span> type;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="comment">//The conditions are checked only if the algorithm is going to change the way it initializes the population.</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="comment">//Policy type 1 is the one with pi bias and is susceptible to loss. CThe algorithm will run until type 0 is found.</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">if</span>(*numvar == N_cut - 1) {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">try</span> {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            type = check_policy(fitarray[1], fitarray[0]);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keywordflow">catch</span>(invalid_argument) {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            fitarray[0] = 0.999999;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            type = check_policy(fitarray[1], fitarray[0]);</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            }</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        mem_ptype[0] = type;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">if</span>(type == 1) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            *numvar = *numvar - 1;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            }</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(type == 0) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            memory_forT[0] = fitarray[0];</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            memory_forT[1] = fitarray[1];</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            }</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">else</span> {}</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*numvar == N_cut) {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">try</span> {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            type = check_policy(fitarray[1], fitarray[0]);</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">catch</span>(invalid_argument) {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            fitarray[0] = 0.999999;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            type = check_policy(fitarray[1], fitarray[0]);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        mem_ptype[1] = type;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">//        if(mem_ptype[0] | type) {</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">if</span>(check_policy(memory_forT[1], memory_forT[0]) | type) {</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="comment">//the policy is bad</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="comment">//reset the policy found in numvar=N_cut-1</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            *numvar = N_cut - 2;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno"><a class="line" href="class_phase.html#a33926c362000620dc76381c4a7b7cf11">  178</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_phase.html#a33926c362000620dc76381c4a7b7cf11">Phase::error_condition</a>(<span class="keywordtype">double</span> *current_fitarray, <span class="keywordtype">double</span> *memory_fitarray, <span class="keywordtype">int</span> data_size, <span class="keywordtype">double</span> goal) {</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">/*This function contains the function to compute error for when the algorithm is set to use error as the accept-reject condition.</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">    *It allows for the information of previous optimization to be used to compute the condition as well as using the latest result.</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">    *In this particular problem, we use the error that corresponds to the confidence interval of 0.98</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">    * from the linear relation between logN and logV_H.</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keywordtype">double</span> slope, intercept;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordtype">double</span> mean_x;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordtype">double</span> tn2;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordtype">double</span> error, error_goal;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="keywordtype">double</span> x[data_size + 1];</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordtype">double</span> y[data_size + 1];</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordtype">bool</span> out;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    memory_fitarray[2 * (data_size)] = log10(<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    memory_fitarray[2 * (data_size) + 1] = log10(pow(current_fitarray[0], -2) - 1);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="comment">//split into x-y arrays</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;= data_size; ++i) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        x[i] = memory_fitarray[2 * i];</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        y[i] = memory_fitarray[2 * i + 1];</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        }</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    </div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="comment">//Computing the linear equation using previous data</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <a class="code" href="aux__functions_8cpp.html#afdf7b535d92d641088f02e2f40d660d4">linear_fit</a>(data_size, x, y, &amp;slope, &amp;intercept, &amp;mean_x);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">//Compute the goal for error from confidence interval of 0.98</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    error_goal = <a class="code" href="aux__functions_8cpp.html#a9c918ef1239379978eeb88f4fd4928ae">error_interval</a>(x, y, mean_x, data_size + 1, slope, intercept);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    goal = (goal + 1) / 2;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    tn2 = <a class="code" href="aux__functions_8cpp.html#abb35e46fe5c0d7e388b61490ce7e0ead">quantile</a>(goal);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    error_goal = error_goal * tn2;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="comment">//Compute the distance between the data and the prediction from linear equation</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    error = y[data_size]-x[data_size] * slope - intercept;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="comment">//Check if error is smaller than the goal</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="keywordflow">if</span>(error &lt;= error_goal) {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        out = 1;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        out = 0;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> out;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    }</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno"><a class="line" href="class_phase.html#a47d8ce9a16f64faa174dd69c3854e3e1">  227</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_phase.html#a47d8ce9a16f64faa174dd69c3854e3e1">Phase::boundary</a>(<span class="keywordtype">double</span> *can1) {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="comment">/*This function cuts the value of the variables so they are within the boundary of the problem.</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">    *This can be replaced by one or more method, such as periodic boundary or normalization.</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++i) {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="keywordflow">if</span>(can1[i] &lt; <a class="code" href="class_problem.html#a4dfde0675e59264970f418516b799b2c">lower_bound</a>[i]) {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            can1[i] = <a class="code" href="class_problem.html#a4dfde0675e59264970f418516b799b2c">lower_bound</a>[i];</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            }</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (can1[i] &gt; <a class="code" href="class_problem.html#a02bd6d1e098e211cc3bf0f5e02f20133">upper_bound</a>[i]) {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            can1[i] = <a class="code" href="class_problem.html#a02bd6d1e098e211cc3bf0f5e02f20133">upper_bound</a>[i];</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    }</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">/*private functions: specific to the simulation and not used by the optimization algorithm*/</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">/*########### Generating Input State ###########*/</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">/*Generation function*/</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="keywordtype">void</span> Phase::WK_state() {</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="comment">/* This is the main function for generating the input state.</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">    * We call it here the Wiseman-Killip state, but the more general term would be the sine state.</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">    * This algorithm for generating WK state is the most precise one to date (measured by how much the normalization differs from zero),</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment">    * but the rounding error still appears as early as N=80 and is detrimental to the shape of the state for N&gt;100.</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">    * This is a limitation caused by the use of double precision float.</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">    * For N&gt;100, either switch to quadruple precision, which will cause a large overhead</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">    * (about 15 for the simulation, but even more for this function), or another method has to be used to approximate the state.</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> beta = M_PI / 2;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> cosN = pow(cos(beta / 2), <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    tan_beta = tan(beta / 2);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keywordtype">int</span> n, k;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keywordtype">double</span> n_part[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordtype">double</span> k_part[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 1];</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordtype">double</span> s_part;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordtype">double</span> temp;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="comment">//Preparing constant arrays to save time.</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="comment">//initializing array of factorial numbers</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    sqrtfac(sqrtfac_mat);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    one_over_fac(overfac_mat);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="comment">/*factors in d_matrix calculated*/</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="comment">//calculating n_parts and k_parts in</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordflow">for</span> (n = 0; n &lt;= <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++n) {</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        n_part[n] = pow(-1.0, n) * sqrtfac_mat[n] * sqrtfac_mat[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> - n] * cosN * pow(tan_beta, n);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        }</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keywordflow">for</span> (k = 0; k &lt;= <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++k) {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        k_part[k] = 1 / pow(-1.0, k) * sqrtfac_mat[k] * sqrtfac_mat[<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> - k] * pow(1 / tan_beta, k);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        }</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="comment">//Compute the state</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keywordflow">for</span> (n = 0; n &lt;= <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++n) { <span class="comment">//we have N+1 state b/c we include n=0 and n=N.</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        temp = 0;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        input_state[n].real(0);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        input_state[n].imag(0);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">for</span> (k = 0; k &lt;= <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++k) {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            s_part = cal_spart(n, k, <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            temp = s_part * k_part[k] * sin((k + 1) * M_PI / (<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> + 2));</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            input_state[n].real(input_state[n].real() + temp * cos(M_PI / 2.0 * (k - n)));</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            input_state[n].imag(input_state[n].imag() + temp * sin(M_PI / 2.0 * (k - n)));</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            }<span class="comment">//end k</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        input_state[n].real(input_state[n].real() * n_part[n] / sqrt(<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> / 2.0 + 1));</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        input_state[n].imag(input_state[n].imag() * n_part[n] / sqrt(<a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a> / 2.0 + 1));</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        }<span class="comment">//end n</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">double</span> Phase::cal_spart(<span class="keyword">const</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> k, <span class="keyword">const</span> <span class="keywordtype">int</span> N) {</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="comment">/*This function calculates the sum in an element of a Wigner d-matrix</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordtype">int</span> s;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordtype">int</span> s_min;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="keywordtype">int</span> s_max;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordtype">double</span> s_part = 0;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="comment">//find lower limit</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">if</span>(n - k &gt;= 0) {</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        s_min = 0;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n - k &lt; 0) {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        s_min = k - n;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">else</span> {}</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">//find upper limit</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <span class="keywordflow">if</span>(k &lt;= N - n) {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        s_max = k;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        }</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(k &gt; N - n) {</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        s_max = N - n;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        }</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <span class="keywordflow">else</span> {}</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="comment">//calculating the s_part</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">for</span> (s = s_min; s &lt;= s_max; ++s) {</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        s_part = s_part + pow(-1.0, s) * overfac_mat[k - s] * overfac_mat[s] * overfac_mat[n - k + s] * overfac_mat[N - n - s] * pow(tan_beta, 2 * s);</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        }</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">return</span> s_part;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    }</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> Phase::one_over_fac(<span class="keywordtype">double</span> *over_mat) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="comment">/*This function calculates one over factorial matrix.*/</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    over_mat[0] = 1;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++i) {</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        over_mat[i] = over_mat[i - 1] / i;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        }<span class="comment">//end i</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    }</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> Phase::sqrtfac(<span class="keywordtype">double</span> *fac_mat) {</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="comment">/*This function calculates sqrare root of factorial matrix.*/</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="comment">//check array size</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    fac_mat[0] = 1;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= <a class="code" href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">num</a>; ++i) {</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        fac_mat[i] = fac_mat[i - 1] * sqrt_cache[i];</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        }<span class="comment">//end i</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    }</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">/*########### Measurement Functions ###########*/</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">/*The following functions are involved in the simulation of the noisy interferometer.*/</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> Phase::noise_outcome(<span class="keyword">const</span> <span class="keywordtype">double</span> phi, <span class="keyword">const</span> <span class="keywordtype">double</span> PHI, <span class="keyword">const</span> <span class="keywordtype">int</span> N) {</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="comment">/*This function computes the output path of a photon from a noisy interferometer</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">    by computing the probablity of photon coming out of either path.</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">    This simulation allows for noise in the unitary operation, but we only consider the noise in the phase shift.</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="comment">//N is the number of photons currently available, not equal to &#39;num&#39;</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> theta = (phi - PHI) / 2.0;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> cos_theta = cos(theta) / sqrt_cache[N];</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> sin_theta = sin(theta) / sqrt_cache[N];</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="comment">//noise in operator: currently not in use</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> oper_n0 = gaussian_rng-&gt;next_rand(0.0, <a class="code" href="phase__loss__opt_8h.html#a5f9ed8ad756b60059d09fb61748ccf90">DEV_N</a>);<span class="comment">//n_x</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> oper_n2 = gaussian_rng-&gt;next_rand(0.0, <a class="code" href="phase__loss__opt_8h.html#a5f9ed8ad756b60059d09fb61748ccf90">DEV_N</a>);<span class="comment">//n_z</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> oper_n1 = sqrt(1.0 - (oper_n0 * oper_n0 + oper_n2 * oper_n2));</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keyword">const</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a> U00(sin_theta * oper_n1, -oper_n0 * sin_theta);</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keyword">const</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a> U01(cos_theta, oper_n2 * sin_theta);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keyword">const</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a> U10(cos_theta, -oper_n2 * sin_theta);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="keyword">const</span> <a class="code" href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a> U11(sin_theta * oper_n1, sin_theta * oper_n0);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordtype">int</span> n;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="keywordtype">double</span> prob = 0.0;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="comment">//if C_0 is measured</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        update0[n] = state[n + 1] * U00 * sqrt_cache[n + 1] + state[n] * U01 * sqrt_cache[N - n];</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        prob += abs(update0[n] * conj(update0[n]));</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">if</span> (uniform_rng-&gt;next_rand(0.0, 1.0) &lt;= prob) {</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="comment">//measurement outcome is 0</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        state[N] = 0;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        prob = 1.0 / sqrt(prob);</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">for</span>(n = 0; n &lt; N; ++n) {</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            state[n] = update0[n] * prob;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            }</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <span class="comment">//measurement outcome is 1</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        prob = 0;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">for</span>(n = 0; n &lt; N; ++n) {</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            state[n] = state[n + 1] * U10 * sqrt_cache[n + 1] - state[n] * U11 * sqrt_cache[N - n];</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            prob += abs(state[n] * conj(state[n]));</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            }</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        state[N] = 0;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        prob = 1.0 / sqrt(prob);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordflow">for</span>(n = 0; n &lt; N; ++n) {</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            state[n] *= prob;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            }</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        }</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    }</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> Phase::state_loss(<span class="keyword">const</span> <span class="keywordtype">int</span> N) {</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="comment">/*This function updates the state when one of the photon is loss.*/</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordtype">double</span> total = 0;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <span class="keywordtype">double</span> factor = 1 / sqrt(2 * N);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; N; ++n) {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        state[n] = (state[n] * sqrt_cache[N - n] + state[n + 1] * sqrt_cache[n + 1]) * factor;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        total += state[n].real() * state[n].real() + state[n].imag() * state[n].imag();</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        }</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    state[N] = 0;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="comment">//Necessary state renormalization</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; N; ++n) {</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        state[n] = state[n] / sqrt(total);</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">double</span> Phase::mod_2PI(<span class="keywordtype">double</span> PHI) {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="comment">/*This function compute the modulo of the phase.</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keywordflow">while</span>(PHI &gt;= 2 * M_PI) {</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        PHI = PHI - 2 * M_PI;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        }</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="keywordflow">while</span> (PHI &lt; 0) {</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        PHI = PHI + 2 * M_PI;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        }</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">return</span> PHI;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> Phase::check_policy(<span class="keywordtype">double</span> error, <span class="keywordtype">double</span> sharp) {</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">/*This function takes the bias and output the policy type.</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment">    *A policy is considered to be type zero if its error falls within the uncertainty of the scheme.</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">    *This is the desirable type as its estimate no bias and the policy can be used when loss is presence.</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">    *In the error falls outside the uncertainty,</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">    *it is very likely that the estimate has a pi bias and is the type of policy that fails when there is loss.</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">if</span> (sharp == 1.0) {</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        <span class="keywordflow">throw</span> invalid_argument(<span class="stringliteral">&quot;sharpness cannot be one.&quot;</span>);</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        }</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordtype">double</span> sd = sqrt(1 / (sharp * sharp) - 1);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">if</span>(fabs(error)&gt;=fabs(M_PI-sd)){</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        }</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="keywordtype">double</span> Phase::rand_Gaussian(<span class="keywordtype">double</span> mean, <span class="comment">/*the average theta*/</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                <span class="keywordtype">double</span> dev <span class="comment">/*deviation for distribution*/</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                ){</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    <span class="comment">/*creating random number using Box-Muller Method/Transformation*/</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="keywordtype">double</span> Z0;<span class="comment">//,Z1;</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordtype">double</span> U1,U2; <span class="comment">/*uniformly distributed random number input*/</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="keywordtype">double</span> r;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    </div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="comment">/*create input between [-1,1]*/</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keywordflow">do</span>{</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    U1=2.0*double(rand())/RAND_MAX-1.0;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    U2=2.0*double(rand())/RAND_MAX-1.0;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    r=U1*U1+U2*U2;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    }<span class="keywordflow">while</span>(r==0.0||r&gt;=1.0);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="comment">/*using Box-Muller Transformation*/</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    Z0=U1*sqrt(-2*log(r)/r);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    </div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">return</span> Z0*dev+mean;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    }<span class="comment">/*end of rand_Gaussian*/</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="keywordtype">double</span> Phase::rand_Hat(<span class="keywordtype">double</span> PHI, <span class="keywordtype">double</span> dev){</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">return</span> gaussian_rng-&gt;next_rand(PHI, dev);</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;}</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">double</span> Phase::inv_erf(<span class="keywordtype">double</span> x) {</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">if</span>(x == 1) {</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="keywordflow">throw</span> invalid_argument(<span class="stringliteral">&quot;Input leads to error.&quot;</span>);</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        }</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keywordtype">double</span> a = 0.140012;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordtype">double</span> lnx = log(1 - x * x);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordtype">double</span> temp = sqrt(pow(2.0 / (M_PI * a) + lnx / 2.0, 2) - lnx / a);</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">return</span> sgn(x) * sqrt(temp - 2.0 / (M_PI * a) - lnx / 2.0);</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    }</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">int</span> Phase::sgn(<span class="keywordtype">double</span> x) {</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="keywordflow">if</span>(x &lt; 0) {</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keywordflow">return</span> -1;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        }</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(x == 0) {</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        }</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        }</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    }</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="keywordtype">double</span> Phase::Lognormal(<span class="keywordtype">double</span> mu, <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> peak) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordtype">double</span> mode = exp(mu - sigma * sigma); <span class="comment">//where the peak is, so we know how much to move the distribution later.</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    <span class="keywordtype">double</span> diff = mode - peak;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keywordtype">double</span> ans;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordtype">double</span> u = (double)(rand()) / ((<span class="keywordtype">double</span>)(RAND_MAX));</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="keywordtype">double</span> p = 2 * u - 1;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">try</span>{</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    ans=exp(sqrt(2) * sigma * inv_erf(p) + mu) - diff;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    }</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keywordflow">catch</span>(invalid_argument){</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    u = (double)(rand()) / ((<span class="keywordtype">double</span>)(RAND_MAX));</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    p = 2 * u - 1;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    ans=exp(sqrt(2) * sigma * inv_erf(p) + mu) - diff;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    }   </div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="keywordtype">double</span> Phase::rand_RTN(<span class="keywordtype">double</span> PHI,<span class="keywordtype">double</span> ps,<span class="keywordtype">double</span> dev){</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordtype">double</span> coin = double(rand())/double(RAND_MAX);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordtype">double</span> ans;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordflow">if</span> (coin&lt;=ps) {</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            coin = double(rand())/double(RAND_MAX);</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            <span class="keywordflow">if</span> (coin&lt;0.5){</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                ans = PHI + dev; </div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            }</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            <span class="keywordflow">else</span>{</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            ans = PHI - dev; </div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        }</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            ans=PHI;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        }</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;}</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="keywordtype">double</span> Phase::rand_skewed(<span class="keywordtype">double</span> mean, <span class="keywordtype">double</span> dev, <span class="keywordtype">double</span> ratio) {</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="keywordtype">double</span> u1, u2;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    <span class="keywordtype">double</span> k1, k2;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    <span class="keywordtype">double</span> alpha = ratio*dev;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    k1 = (1 + alpha) / sqrt(2 * (1 + alpha * alpha));</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    k2 = (1 - alpha) / sqrt(2 * (1 + alpha * alpha));</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    u1 = rand_Gaussian(0, 1);</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    u2 = rand_Gaussian(0, 1);</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordflow">return</span> (k1 * max(u1, u2) + k2 * min(u1, u2))*dev+mean;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    }</div><div class="ttc" id="phase__loss__opt_8h_html_a5f9ed8ad756b60059d09fb61748ccf90"><div class="ttname"><a href="phase__loss__opt_8h.html#a5f9ed8ad756b60059d09fb61748ccf90">DEV_N</a></div><div class="ttdeci">#define DEV_N</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8h_source.html#l00009">phase_loss_opt.h:9</a></div></div>
<div class="ttc" id="aux__functions_8cpp_html_afdf7b535d92d641088f02e2f40d660d4"><div class="ttname"><a href="aux__functions_8cpp.html#afdf7b535d92d641088f02e2f40d660d4">linear_fit</a></div><div class="ttdeci">void linear_fit(int data_size, double *x, double *y, double *slope, double *intercept, double *mean_x)</div><div class="ttdoc">This library contains the functions for linear regression.</div><div class="ttdef"><b>Definition:</b> <a href="aux__functions_8cpp_source.html#l00007">aux_functions.cpp:7</a></div></div>
<div class="ttc" id="class_phase_html_a33926c362000620dc76381c4a7b7cf11"><div class="ttname"><a href="class_phase.html#a33926c362000620dc76381c4a7b7cf11">Phase::error_condition</a></div><div class="ttdeci">bool error_condition(double *current_fitarray, double *memory_fitarray, int data_size, double goal)</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00178">phase_loss_opt.cpp:178</a></div></div>
<div class="ttc" id="aux__functions_8cpp_html_abb35e46fe5c0d7e388b61490ce7e0ead"><div class="ttname"><a href="aux__functions_8cpp.html#abb35e46fe5c0d7e388b61490ce7e0ead">quantile</a></div><div class="ttdeci">double quantile(double p)</div><div class="ttdef"><b>Definition:</b> <a href="aux__functions_8cpp_source.html#l00069">aux_functions.cpp:69</a></div></div>
<div class="ttc" id="phase__loss__opt_8h_html"><div class="ttname"><a href="phase__loss__opt_8h.html">phase_loss_opt.h</a></div></div>
<div class="ttc" id="phase__loss__opt_8h_html_a84ee68ee1444d9432f7dc7e67b7e5f51"><div class="ttname"><a href="phase__loss__opt_8h.html#a84ee68ee1444d9432f7dc7e67b7e5f51">THETA_DEV</a></div><div class="ttdeci">#define THETA_DEV</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8h_source.html#l00011">phase_loss_opt.h:11</a></div></div>
<div class="ttc" id="class_phase_html_a73864e5e5e43b6fb301cf507eeb118a4"><div class="ttname"><a href="class_phase.html#a73864e5e5e43b6fb301cf507eeb118a4">Phase::avg_fitness</a></div><div class="ttdeci">void avg_fitness(double *soln, const int K, double *fitarray)</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00073">phase_loss_opt.cpp:73</a></div></div>
<div class="ttc" id="class_problem_html_a02bd6d1e098e211cc3bf0f5e02f20133"><div class="ttname"><a href="class_problem.html#a02bd6d1e098e211cc3bf0f5e02f20133">Problem::upper_bound</a></div><div class="ttdeci">double * upper_bound</div><div class="ttdef"><b>Definition:</b> <a href="problem_8h_source.html#l00037">problem.h:37</a></div></div>
<div class="ttc" id="class_phase_html_a9907413eb9a96148934d71864bb7e41b"><div class="ttname"><a href="class_phase.html#a9907413eb9a96148934d71864bb7e41b">Phase::~Phase</a></div><div class="ttdeci">~Phase()</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00051">phase_loss_opt.cpp:51</a></div></div>
<div class="ttc" id="class_phase_html_ab7c1a08ef8d03c0e1ec72caf0056a5f0"><div class="ttname"><a href="class_phase.html#ab7c1a08ef8d03c0e1ec72caf0056a5f0">Phase::T_condition</a></div><div class="ttdeci">bool T_condition(double *fitarray, int *numvar, int N_cut, bool *mem_ptype, double *memory_forT)</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00130">phase_loss_opt.cpp:130</a></div></div>
<div class="ttc" id="class_problem_html_a11dbb1d5a91b82ac8bab777362003e43"><div class="ttname"><a href="class_problem.html#a11dbb1d5a91b82ac8bab777362003e43">Problem::num_fit</a></div><div class="ttdeci">int num_fit</div><div class="ttdef"><b>Definition:</b> <a href="problem_8h_source.html#l00041">problem.h:41</a></div></div>
<div class="ttc" id="class_phase_html_a3400d37e26b0f5f785db31d7887a6d76"><div class="ttname"><a href="class_phase.html#a3400d37e26b0f5f785db31d7887a6d76">Phase::Phase</a></div><div class="ttdeci">Phase(const int numvar, Rng *gaussian_rng, Rng *uniform_rng)</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00010">phase_loss_opt.cpp:10</a></div></div>
<div class="ttc" id="class_phase_html_ab25270a4c4dda786a14028daf70a1da8"><div class="ttname"><a href="class_phase.html#ab25270a4c4dda786a14028daf70a1da8">Phase::fitness</a></div><div class="ttdeci">void fitness(double *soln, double *fitarray)</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00064">phase_loss_opt.cpp:64</a></div></div>
<div class="ttc" id="class_problem_html_a4dfde0675e59264970f418516b799b2c"><div class="ttname"><a href="class_problem.html#a4dfde0675e59264970f418516b799b2c">Problem::lower_bound</a></div><div class="ttdeci">double * lower_bound</div><div class="ttdef"><b>Definition:</b> <a href="problem_8h_source.html#l00036">problem.h:36</a></div></div>
<div class="ttc" id="phase__loss__opt_8h_html_a7e8b3c8482e593df0ace933ad3de22ee"><div class="ttname"><a href="phase__loss__opt_8h.html#a7e8b3c8482e593df0ace933ad3de22ee">RATIO</a></div><div class="ttdeci">#define RATIO</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8h_source.html#l00015">phase_loss_opt.h:15</a></div></div>
<div class="ttc" id="class_phase_html_a47d8ce9a16f64faa174dd69c3854e3e1"><div class="ttname"><a href="class_phase.html#a47d8ce9a16f64faa174dd69c3854e3e1">Phase::boundary</a></div><div class="ttdeci">void boundary(double *can1)</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8cpp_source.html#l00227">phase_loss_opt.cpp:227</a></div></div>
<div class="ttc" id="phase__loss__opt_8h_html_a98ebca80a317b58c1386b356909f7dea"><div class="ttname"><a href="phase__loss__opt_8h.html#a98ebca80a317b58c1386b356909f7dea">dcmplx</a></div><div class="ttdeci">complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="phase__loss__opt_8h_source.html#l00025">phase_loss_opt.h:25</a></div></div>
<div class="ttc" id="class_problem_html_ae46e65561288cc81f06c2ddae062d303"><div class="ttname"><a href="class_problem.html#ae46e65561288cc81f06c2ddae062d303">Problem::num</a></div><div class="ttdeci">int num</div><div class="ttdef"><b>Definition:</b> <a href="problem_8h_source.html#l00039">problem.h:39</a></div></div>
<div class="ttc" id="aux__functions_8cpp_html_a9c918ef1239379978eeb88f4fd4928ae"><div class="ttname"><a href="aux__functions_8cpp.html#a9c918ef1239379978eeb88f4fd4928ae">error_interval</a></div><div class="ttdeci">double error_interval(double *x, double *y, double mean_x, int data_size, double slope, double intercept)</div><div class="ttdef"><b>Definition:</b> <a href="aux__functions_8cpp_source.html#l00032">aux_functions.cpp:32</a></div></div>
<div class="ttc" id="rng_8h_html_a0d95a1c4bd7f6516941df17732a09356"><div class="ttname"><a href="rng_8h.html#a0d95a1c4bd7f6516941df17732a09356">Rng</a></div><div class="ttdeci">#define Rng</div><div class="ttdef"><b>Definition:</b> <a href="rng_8h_source.html#l00090">rng.h:90</a></div></div>
<div class="ttc" id="class_problem_html_a02dc7cd36750260516f536d4b519399d"><div class="ttname"><a href="class_problem.html#a02dc7cd36750260516f536d4b519399d">Problem::num_repeat</a></div><div class="ttdeci">int num_repeat</div><div class="ttdef"><b>Definition:</b> <a href="problem_8h_source.html#l00040">problem.h:40</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
